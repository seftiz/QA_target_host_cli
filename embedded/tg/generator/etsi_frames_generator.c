

#include <stdio.h>
#include <stdint.h>
#include <tx_api.h>


#include <nxd_bsd.h>
#include <libcli.h>

#include <craton/cli.h>

#include <atlk/can.h>
#include <atlk/can_service.h>

#include <atlk/v2x.h>
#include <atlk/sdk.h>
#include <atlk/v2x_service.h>

#include <craton/v2x_hw.h>
#include <craton/sha_hw.h>

#include <atlk/sha.h>

#include <atlk/ecc.h>
#include <atlk/ecdsa.h>
#include <atlk/ecc_service.h>

#include <atlk/mib_service.h>
#include <atlk/mibs/vca-mib.h>
#include <atlk/mibs/wlan-mib.h>
#include <atlk/mibs/if-mib.h>

#include <atlk/nav_service.h>
#include <atlk/eui48.h>


#include "etsi_frames_generator.h"


void print_counters( void );
void debug_printf(const char *format, ...);
int craton_rf_init( void );
void usleep(long usecs);


int get_nav_info( void );

void fmt_i2osp(const uint32_t *input, uint8_t *output, size_t u32_len);
void fmt_os2ip(const uint8_t *input, uint32_t *output, size_t u32_len);


int create_denm_packet( uint8_t **packet, uint32_t *packet_size, signing_opt_t sign_frame, uint32_t cert_id, eui48_t mac, uint32_t station_id );


#ifdef __CRATON_ARM

/* NOTE : EFG stands for ETSI FRAME GENERATOR */

/* Create services */
static nav_fix_subscriber_t *nav_subscriber = NULL;
static v2x_socket_t 				*v2x_socket; /** Link layer socket */
static nav_service_t 				*nav_service = NULL;
static mib_service_t 				*mib_service = NULL;
static uint32_t							tg_frame_sleep = 1000000; /* 0 is disable,  500 mSec sleep --> 2 Frames in sec */

static uint32_t             frame_rate          = 0;
static uint32_t							stations_simulated  = 1; 
// static uint32_t							denm_seq_cntr       = 0; 
static uint8_t							cntr_print          = 0; 
static uint32_t	            station_id			    = 1;
static nav_fix_t            nav_fix             = NAV_FIX_INIT;
  
/* Security services */
static ecc_service_t 				*ecc_service = NULL;
static ecc_signing_socket_t	*ecc_sign_socket = NULL;

static uint8_t               sec_active     = 0,
                             send_full_chain      = 0,
                             send_full_chain_rate = 0;

static uint32_t              counters[LAST_COUNTER] = { 0 };


atlk_wait_t				hello;

#define TOTAL_FRM_TYPES 4
static uint32_t               tx_frames[TOTAL_FRM_TYPES] = { 0 };

  



/** 
	AA certificate * Note: the AA certificate below is one of those used during the 2013 ETSI  
	Plugtest (hashedId8=a8ed6df65b0e6d6a) 
*/

static const uint8_t aa_cert[] ={ 0x01,0x09,0x01,0x83,0xca,0x21,0x68,0xb7,0x84,0xfc,0x6c,0x02,0x10,0x50,0x69,0x6c,0x6f,0x74,0x50,0x4b,0x49,0x5f,0x50,0x43,0x41,0x5f,0x53,0x49,0x54,0x80,0x91,0x00,0x00,0x04,0x0d,0x46,0x61,0xbf,0x77,0xf6,0x71,0x71,0x6e,0xa7,0x4e,0xa4,0xcd,0x92,0xef,0x5a,0x45,0x66,0xbe,0xea,0x66,0x81,0xed,0x04,0x4b,0x09,0xc3,0x1e,0xa4,0x7d,0x42,0xb3,0x88,0x93,0x2a,0x9b,0x2d,0xa9,0x57,0xf3,0xfd,0x2e,0x12,0x56,0xda,0xc8,0x06,0x9b,0x15,0x44,0xbf,0x29,0x88,0xd4,0x3e,0xf0,0x9b,0x8a,0xab,0xc6,0x78,0x13,0x46,0x5e,0x01,0x01,0x00,0x04,0x33,0x61,0xe7,0x3d,0xff,0x9b,0xc8,0x9c,0x42,0xf4,0x54,0x2a,0xac,0x7f,0xdd,0x9a,0x5a,0xba,0x66,0x53,0x10,0x87,0xd1,0xc3,0x1c,0x5a,0x95,0xb6,0x78,0x8e,0x06,0xbc,0x08,0xf9,0x40,0x2d,0x3e,0xd4,0x75,0x6a,0x6f,0xb0,0x69,0x37,0xf2,0xa9,0x19,0x83,0x38,0x41,0x35,0x8d,0x05,0x2f,0xb6,0xc9,0xaf,0x4c,0xc1,0xf6,0x84,0xc3,0xb7,0x6a,0x02,0xe0,0x20,0x06,0xc0,0x40,0x80,0xc0,0x40,0x81,0x0b,0x01,0x05,0xa4,0xec,0x01,0x10,0xec,0x21,0x01,0x03,0x00,0x00,0x00,0xc6,0x4e,0x89,0xa2,0x35,0x28,0xf5,0x0d,0x8a,0xf8,0x53,0x62,0x90,0xfe,0x9e,0x78,0xcc,0x26,0xf5,0x1d,0x6b,0x42,0x78,0xec,0x08,0x63,0x83,0xa4,0xaf,0xea,0xba,0x96,0x1a,0xd3,0x8a,0x2f,0xb2,0x86,0xd0,0xf0,0x75,0xde,0xdb,0x0c,0x79,0x29,0x96,0x0d,0x35,0x86,0x5e,0x80,0xa3,0xa0,0x22,0xca,0xc7,0x72,0xf1,0xda,0xca,0x6f,0x87,0x5a};

// static const uint8_t at_cert[] = { 0x01,0x09,0x01,0xa8,0xed,0x6d,0xf6,0x5b,0x0e,0x6d,0x6a,0x01,0x00,0x51,0x00,0x00,0x04,0x96,0x5e,0xdb,0xf7,0x48,0xa9,0xa1,0x35,0x8e,0x49,0x1d,0xd4,0xee,0xd8,0xe4,0xac,0xb2,0x6e,0x80,0xb7,0x48,0x9b,0x0b,0x38,0xb8,0x8b,0x72,0x4f,0x6d,0x32,0xb7,0xe1,0x16,0x2b,0x89,0xa6,0x8c,0xc9,0xa2,0xad,0xf0,0xfe,0x15,0xae,0x39,0x36,0x2a,0xf3,0x9b,0x67,0x6b,0xa2,0xb5,0x68,0x40,0x30,0x1e,0x1d,0xa3,0x49,0x09,0x81,0xa0,0xfd,0x02,0xe0,0x21,0x0a,0xc0,0x40,0x80,0x01,0x00,0xc0,0x40,0x81,0x01,0x00,0x0b,0x01,0x06,0xbc,0x6a,0x01,0x07,0x82,0x2b,0x00,0x03,0x00,0x00,0x00,0x77,0xfb,0x8e,0x6c,0x6d,0xe6,0xd6,0x83,0xc8,0x7a,0x2a,0xb1,0xee,0x5d,0x36,0x87,0xcc,0x9c,0xa4,0xf8,0xed,0x10,0x21,0x47,0x10,0xfe,0x25,0x42,0x20,0x95,0x5d,0xed,0xb9,0xa0,0x81,0x07,0x76,0xc1,0xb8,0x49,0xa9,0x6a,0xbf,0x79,0x5a,0xca,0x2c,0xc0,0x10,0x85,0x86,0x0d,0x9c,0xd3,0x40,0x5d,0x67,0x38,0x9b,0xda,0x6c,0xb4,0xd7,0x27};

  
static const uint8_t at_certs[][173] = { /* cert & key pairs */
        { 0x01,0x09,0x01,0xa8,0xed,0x6d,0xf6,0x5b,0x0e,0x6d,0x6a,0x01,0x00,0x51,0x00,0x00,0x04,0xac,0x08,0xb7,0x6e,0xa4,0x13,0xac,0xd2,0x4f,0xbe,0x80,0x76,0x86,0xeb,0x58,0xe0,0x7a,0xe1,0x03,0x88,0x9b,0x49,0xe9,0xf1,0x17,0xdb,0x65,0xac,0xf2,0xcb,0x19,0x1d,0x22,0x77,0xd0,0x56,0x4e,0xa3,0xb4,0x45,0x90,0x17,0x02,0x6d,0x16,0xf1,0x81,0xce,0x09,0x06,0x4c,0x89,0xb3,0xcf,0x0e,0x70,0x34,0xc1,0x93,0xac,0x27,0xdd,0xe1,0xfc,0x02,0xe0,0x21,0x0a,0xc0,0x40,0x80,0x01,0x00,0xc0,0x40,0x81,0x01,0x00,0x0b,0x01,0x06,0xbc,0x6a,0x01,0x07,0x82,0x2b,0x00,0x03,0x00,0x00,0x00,0xd1,0xf1,0xfc,0x0f,0x33,0x0e,0xf6,0x6b,0xf6,0xc3,0xee,0x01,0x7b,0x4a,0xa0,0x44,0xb5,0x47,0x8c,0x51,0x2a,0xcf,0x4c,0x2e,0x76,0x2c,0x3d,0x8f,0xbb,0x49,0x7b,0xf8,0x4f,0x42,0x7a,0x92,0xcf,0xa9,0x87,0xf6,0xe7,0x35,0x37,0x0e,0x1c,0xb4,0x49,0x8d,0x03,0x4c,0x6e,0xf6,0x8d,0x07,0x1f,0x31,0x24,0x32,0x73,0x04,0x8a,0x51,0xbc,0x6c },
        { 0x01,0x09,0x01,0xa8,0xed,0x6d,0xf6,0x5b,0x0e,0x6d,0x6a,0x01,0x00,0x51,0x00,0x00,0x04,0x8f,0x4c,0x16,0x47,0x76,0x76,0x59,0xdc,0x0b,0xac,0x76,0xa2,0x88,0xf0,0x92,0xb7,0x91,0x07,0xf1,0xb8,0xd0,0x2a,0xaa,0x81,0x69,0x00,0x5d,0x8c,0xd0,0xe1,0x34,0x71,0x14,0x5b,0x36,0xcb,0x02,0xe2,0xef,0xbc,0xd7,0x54,0xba,0x88,0x3f,0xe4,0x78,0xc9,0xdb,0x64,0x6a,0x23,0x7d,0xac,0x0d,0xd6,0x1f,0x79,0x10,0x51,0xd9,0x35,0xe0,0x55,0x02,0xe0,0x21,0x0a,0xc0,0x40,0x80,0x01,0x00,0xc0,0x40,0x81,0x01,0x00,0x0b,0x01,0x06,0xbc,0x6a,0x01,0x07,0x82,0x2b,0x00,0x03,0x00,0x00,0x00,0x28,0xae,0xa7,0x01,0x9f,0xb0,0x1d,0xa6,0xcc,0x50,0xec,0x3a,0x00,0x10,0x11,0x88,0x44,0x15,0x4c,0xfa,0xce,0x7c,0x22,0x47,0x0b,0xd8,0x18,0x06,0xf3,0x7d,0xd0,0x75,0x6a,0xb1,0xf5,0x6b,0x91,0xeb,0xbb,0x9d,0x1f,0x3a,0x8f,0x6d,0xed,0xf8,0x52,0x15,0x2a,0x94,0x26,0x12,0xa5,0x1b,0xb4,0x02,0xb5,0x1e,0x04,0x54,0x2c,0x27,0xad,0x88 },
        { 0x01,0x09,0x01,0xa8,0xed,0x6d,0xf6,0x5b,0x0e,0x6d,0x6a,0x01,0x00,0x51,0x00,0x00,0x04,0xe3,0x64,0x29,0xa9,0x75,0x0d,0x4b,0xa9,0x61,0x55,0x69,0xbb,0x37,0x60,0xae,0x74,0xc6,0xd7,0x0f,0x50,0x40,0xdd,0x8e,0x88,0x15,0x2a,0xe7,0x3b,0x09,0x43,0x29,0x03,0x5e,0xdd,0xd9,0xe0,0x5d,0x4a,0xe9,0xc9,0xb5,0x4b,0x10,0x07,0xef,0x73,0x2c,0xc5,0x23,0x67,0xab,0x05,0xa7,0x9b,0x3d,0xad,0x40,0x81,0x89,0x6c,0x8a,0x41,0xbf,0xcf,0x02,0xe0,0x21,0x0a,0xc0,0x40,0x80,0x01,0x00,0xc0,0x40,0x81,0x01,0x00,0x0b,0x01,0x06,0xbc,0x6a,0x01,0x07,0x82,0x2b,0x00,0x03,0x00,0x00,0x00,0x62,0x5d,0xe1,0xec,0xce,0xd4,0xfb,0xba,0xb4,0x5b,0x15,0x6a,0x26,0xe5,0xf8,0x87,0x25,0x97,0x7f,0x52,0x03,0xd2,0x88,0x37,0xf3,0xa2,0x66,0x79,0x73,0x9b,0x85,0x50,0xc8,0xdd,0x06,0xc3,0xd2,0x01,0x5f,0x12,0xdb,0xc5,0xdf,0x9e,0x58,0x3a,0x0e,0x59,0x7d,0x50,0x3e,0xfc,0xfd,0xd0,0xc9,0xc3,0x2d,0x7f,0x15,0xad,0x62,0x1f,0x99,0xb7 },
        { 0x01,0x09,0x01,0xa8,0xed,0x6d,0xf6,0x5b,0x0e,0x6d,0x6a,0x01,0x00,0x51,0x00,0x00,0x04,0x4b,0x0f,0xd4,0xe6,0x56,0x19,0xaa,0x15,0x23,0xd1,0x22,0x16,0xf1,0x5b,0x57,0x37,0xf8,0x51,0x17,0xd6,0x0b,0x1f,0x0d,0xb5,0xbc,0x6c,0x73,0xa0,0x2e,0x91,0xbe,0x21,0x94,0x12,0x33,0x4d,0xe4,0xdc,0xf3,0x78,0x70,0x47,0xcf,0x78,0xa7,0xda,0x74,0x5f,0x52,0x8e,0x09,0x9a,0x62,0x89,0x03,0x5a,0xa4,0x19,0x68,0x2f,0xa1,0xea,0x6d,0x61,0x02,0xe0,0x21,0x0a,0xc0,0x40,0x80,0x01,0x00,0xc0,0x40,0x81,0x01,0x00,0x0b,0x01,0x06,0xbc,0x6a,0x01,0x07,0x82,0x2b,0x00,0x03,0x00,0x00,0x00,0x5a,0xfb,0xf7,0x42,0x6c,0x20,0x63,0x60,0xb9,0x46,0xc9,0x79,0x37,0xb3,0xd4,0xdd,0x79,0x5c,0x39,0xb0,0x72,0xed,0x15,0x20,0xe5,0xb5,0xe9,0x19,0x1c,0x80,0xc0,0x3f,0x98,0x27,0x58,0x88,0xbf,0xc7,0x72,0xbf,0x05,0x9c,0x69,0xc0,0xcc,0x6f,0xea,0xf4,0x89,0x27,0xc1,0xc4,0x73,0xe8,0x85,0x89,0x8b,0xc6,0x6b,0x5f,0x5c,0x2e,0xc2,0xa4 },
        { 0x01,0x09,0x01,0xa8,0xed,0x6d,0xf6,0x5b,0x0e,0x6d,0x6a,0x01,0x00,0x51,0x00,0x00,0x04,0x9c,0xd8,0x5d,0xc7,0x52,0x66,0xad,0x99,0x55,0xf3,0x5a,0x66,0xdf,0x47,0x8e,0x7c,0xfe,0x19,0xc6,0x6f,0x35,0x88,0xa6,0xc8,0x75,0x6a,0x5f,0xc5,0x6e,0xea,0x0b,0x57,0x3f,0x22,0x8f,0x42,0x74,0xa9,0xb6,0x98,0x61,0x2f,0xd5,0x98,0x60,0xab,0xe0,0xb2,0x15,0xed,0xaa,0x6e,0xa4,0x5e,0xc6,0xa9,0xa6,0x3c,0x30,0xf2,0x39,0x89,0x87,0x52,0x02,0xe0,0x21,0x0a,0xc0,0x40,0x80,0x01,0x00,0xc0,0x40,0x81,0x01,0x00,0x0b,0x01,0x06,0xbc,0x6a,0x01,0x07,0x82,0x2b,0x00,0x03,0x00,0x00,0x00,0xc7,0xf1,0xcb,0x17,0xa3,0x3d,0x5c,0x62,0xae,0x61,0x41,0x6f,0x3a,0x1d,0x5c,0x02,0xed,0x12,0xd7,0x41,0x2a,0x2a,0xb7,0xb0,0x07,0x73,0x05,0x19,0x14,0x15,0x64,0x2d,0x88,0x8a,0xad,0xec,0x09,0x77,0x6c,0x4e,0x2e,0xf5,0xa3,0xa2,0x04,0x91,0xd3,0x4d,0x91,0xb9,0x2f,0x10,0x92,0x7f,0xea,0xe2,0xc7,0xdd,0xb7,0x5c,0x4a,0x3f,0xc0,0x32 },
        { 0x01,0x09,0x01,0xa8,0xed,0x6d,0xf6,0x5b,0x0e,0x6d,0x6a,0x01,0x00,0x51,0x00,0x00,0x04,0x70,0x4a,0x48,0xef,0xcf,0x62,0x33,0x5f,0xf8,0xc4,0x8c,0x88,0x9c,0x90,0xce,0xc8,0x12,0x22,0xbe,0x41,0xbf,0x36,0x6b,0xec,0x53,0x1a,0xfc,0xb4,0x1d,0x16,0x5c,0xe9,0xba,0xe0,0x71,0x51,0x3e,0xd9,0xd2,0x69,0xde,0xf1,0xd7,0x36,0x3d,0x94,0x04,0xef,0x48,0xfb,0x38,0x7c,0xfd,0x12,0x25,0x87,0x6e,0x96,0x10,0xfc,0xc8,0x0a,0x45,0xc5,0x02,0xe0,0x21,0x0a,0xc0,0x40,0x80,0x01,0x00,0xc0,0x40,0x81,0x01,0x00,0x0b,0x01,0x06,0xbc,0x6a,0x01,0x07,0x82,0x2b,0x00,0x03,0x00,0x00,0x00,0x83,0xc6,0xd5,0x59,0x22,0x63,0xc1,0x46,0x3d,0x20,0xa4,0xd8,0x76,0xce,0x9b,0xe9,0x20,0x3d,0xaa,0xac,0x0f,0x7a,0xce,0x27,0x40,0x06,0xb1,0xd0,0x53,0x9d,0x6a,0xe9,0xf3,0x1f,0x3f,0x29,0xa1,0x78,0xaa,0x4b,0x19,0x1e,0x2f,0xa8,0x47,0x21,0x09,0x47,0x57,0xbd,0x73,0x94,0x40,0x82,0xbb,0x70,0x39,0xd1,0x1c,0x58,0x4b,0xe2,0xd7,0xe8 },
        { 0x01,0x09,0x01,0xa8,0xed,0x6d,0xf6,0x5b,0x0e,0x6d,0x6a,0x01,0x00,0x51,0x00,0x00,0x04,0x00,0x1b,0xd3,0x8c,0xfa,0x58,0x2f,0x7a,0xe2,0xfc,0x78,0xad,0xf7,0x6d,0xc0,0x14,0xaf,0x0c,0x01,0x64,0x4a,0xdb,0x9c,0x2a,0xcf,0x12,0xd4,0xb0,0x0a,0xa2,0xe0,0x71,0x7d,0x66,0x41,0x67,0x46,0x97,0x93,0x87,0x52,0x02,0x32,0x12,0xc6,0xc6,0xf8,0x7d,0x14,0xa2,0x3e,0x70,0xa4,0x41,0xc3,0x26,0x69,0xa2,0xf3,0x28,0x6f,0x86,0x40,0x5a,0x02,0xe0,0x21,0x0a,0xc0,0x40,0x80,0x01,0x00,0xc0,0x40,0x81,0x01,0x00,0x0b,0x01,0x06,0xbc,0x6a,0x01,0x07,0x82,0x2b,0x00,0x03,0x00,0x00,0x00,0x4e,0x43,0xfd,0xc6,0xae,0x4a,0x9f,0xcc,0xd1,0x6b,0xd3,0x89,0xb2,0xd1,0x5f,0x66,0x92,0x87,0x09,0x64,0x1e,0x6a,0xd5,0x25,0x2b,0x1b,0x08,0x33,0x7d,0x13,0x2c,0x23,0x7b,0x23,0xe6,0x48,0x30,0x88,0x7d,0x6f,0xbc,0xcd,0xb1,0xee,0xfd,0x53,0xaa,0x7f,0x31,0x9b,0x4c,0xd1,0x21,0x0d,0x5a,0xc2,0xb8,0x80,0x72,0x0d,0x22,0xed,0x1d,0xd5 },
        { 0x01,0x09,0x01,0xa8,0xed,0x6d,0xf6,0x5b,0x0e,0x6d,0x6a,0x01,0x00,0x51,0x00,0x00,0x04,0xd2,0xbe,0x82,0xc8,0xb5,0xb6,0x0e,0x16,0xc5,0xac,0x2d,0xa0,0x2d,0x72,0xd9,0x1e,0xd6,0xed,0x4c,0xd1,0xda,0x50,0xc5,0x6a,0xb8,0x39,0xac,0x1b,0xc8,0x1e,0x07,0x5e,0xed,0x33,0xd1,0x2c,0x54,0x85,0xb9,0x06,0xb6,0x2a,0xde,0x31,0x4e,0x05,0xef,0x87,0xfc,0xeb,0xfb,0x7c,0x81,0x3f,0x57,0x3b,0x9c,0xcd,0x10,0x4f,0x45,0x6d,0xa2,0x5a,0x02,0xe0,0x21,0x0a,0xc0,0x40,0x80,0x01,0x00,0xc0,0x40,0x81,0x01,0x00,0x0b,0x01,0x06,0xbc,0x6a,0x01,0x07,0x82,0x2b,0x00,0x03,0x00,0x00,0x00,0x67,0xc5,0xea,0x35,0x07,0x07,0x6b,0xd4,0x0c,0x8c,0x0d,0x1f,0x06,0xc5,0x46,0x8b,0x8d,0x15,0xda,0x56,0xc1,0x9b,0xd5,0xf8,0x0d,0x6d,0x56,0xd2,0x52,0x93,0x0e,0x89,0xbd,0x5c,0x92,0xdc,0x14,0x3b,0xcb,0xd8,0x13,0x4a,0xa6,0xaf,0x0a,0xb4,0xb3,0x38,0x0b,0x20,0xa8,0x2b,0xe5,0x9d,0x85,0x26,0x23,0x64,0x19,0x9b,0xbd,0x63,0xff,0x50 },
        { 0x01,0x09,0x01,0xa8,0xed,0x6d,0xf6,0x5b,0x0e,0x6d,0x6a,0x01,0x00,0x51,0x00,0x00,0x04,0x83,0x47,0x06,0xd5,0xed,0x3c,0x45,0x8d,0x35,0x36,0x12,0xc0,0x56,0x26,0x73,0xc0,0x0a,0xef,0xd2,0x3e,0xfa,0xbb,0x07,0xb6,0x03,0x79,0xbc,0xcb,0x37,0x59,0x35,0xee,0xac,0x7a,0xd2,0xe8,0x40,0x96,0xe0,0x83,0x14,0x0d,0xf6,0x92,0xae,0x08,0x0c,0xf0,0xe7,0xb7,0x94,0x3b,0x65,0x5a,0x27,0x77,0xce,0xa3,0xf6,0xf4,0x23,0x36,0x12,0x6c,0x02,0xe0,0x21,0x0a,0xc0,0x40,0x80,0x01,0x00,0xc0,0x40,0x81,0x01,0x00,0x0b,0x01,0x06,0xbc,0x6a,0x01,0x07,0x82,0x2b,0x00,0x03,0x00,0x00,0x00,0x91,0x0e,0x94,0x41,0xa8,0x45,0x65,0xb6,0xa6,0x4a,0xa1,0x59,0x4c,0x3e,0x7c,0x10,0x72,0x91,0xfc,0xd5,0x18,0x1d,0x7c,0xf9,0x26,0xae,0x72,0xad,0xf0,0x9c,0xe1,0x0a,0x18,0x87,0x80,0x8f,0x50,0x09,0xd2,0xed,0x39,0xb9,0x3a,0xd8,0x81,0xec,0xf9,0x6f,0x64,0x4e,0xee,0x6d,0x47,0x28,0x6f,0xd1,0xa5,0xe2,0xf1,0xcf,0x59,0x75,0xdc,0x04 },
        { 0x01,0x09,0x01,0xa8,0xed,0x6d,0xf6,0x5b,0x0e,0x6d,0x6a,0x01,0x00,0x51,0x00,0x00,0x04,0xf4,0xd4,0x6e,0x01,0xda,0xbf,0x24,0x6a,0x96,0xb8,0x00,0x5d,0x5e,0x43,0xd7,0xf1,0x1e,0x94,0xac,0x88,0x23,0xb8,0xf4,0xe1,0xbf,0xb5,0x4d,0x46,0x34,0x4d,0x3e,0xa6,0x50,0x24,0x86,0xf7,0xba,0x2c,0xbc,0x99,0x90,0x2d,0x60,0x20,0xd2,0x07,0x5b,0xbb,0x2a,0xed,0x03,0x92,0x1a,0x02,0x2d,0x69,0xd1,0x6a,0xdd,0x4d,0x64,0xb9,0x59,0x59,0x02,0xe0,0x21,0x0a,0xc0,0x40,0x80,0x01,0x00,0xc0,0x40,0x81,0x01,0x00,0x0b,0x01,0x06,0xbc,0x6a,0x01,0x07,0x82,0x2b,0x00,0x03,0x00,0x00,0x00,0x4e,0x48,0xf5,0x64,0x75,0x52,0xc2,0xf1,0x43,0xba,0x5d,0x23,0x26,0xd8,0x3c,0x20,0xdd,0xc4,0x4a,0x93,0x27,0x1b,0x0a,0x1f,0x5e,0x3c,0xab,0x4c,0xe9,0x64,0x76,0xe5,0xc9,0x50,0x2f,0x97,0xf0,0xd8,0x8d,0xa8,0xc4,0x7b,0x08,0x70,0xe3,0x12,0xf8,0xd2,0x0f,0x6e,0xa3,0xba,0x69,0x52,0xed,0x39,0x67,0x20,0x55,0x32,0xb6,0x36,0x63,0x4a },
        { 0x01,0x09,0x01,0xa8,0xed,0x6d,0xf6,0x5b,0x0e,0x6d,0x6a,0x01,0x00,0x51,0x00,0x00,0x04,0xba,0x4c,0x4d,0x52,0x73,0x86,0x98,0x92,0x09,0x47,0x65,0x70,0x42,0x0e,0xde,0xcd,0xc9,0xf7,0xb0,0xa1,0x61,0x58,0x3b,0x05,0x38,0xde,0x4c,0xf4,0x86,0x71,0x21,0x27,0x55,0x14,0x4a,0x5a,0x21,0xfa,0x0d,0x20,0xc1,0x8a,0xaa,0x36,0xda,0x48,0x42,0x51,0x9b,0x29,0x77,0x4b,0xb4,0x50,0x23,0x18,0xd3,0x64,0xc8,0x4f,0xa3,0x36,0xbb,0xca,0x02,0xe0,0x21,0x0a,0xc0,0x40,0x80,0x01,0x00,0xc0,0x40,0x81,0x01,0x00,0x0b,0x01,0x06,0xbc,0x6a,0x01,0x07,0x82,0x2b,0x00,0x03,0x00,0x00,0x00,0xc2,0xd9,0x6d,0x1d,0x0e,0xc0,0xc0,0x31,0x84,0xf4,0x54,0xf7,0x73,0x5b,0xdc,0x73,0x74,0x01,0x00,0xdb,0x78,0x22,0x74,0x5c,0x73,0x04,0xd4,0x31,0x9a,0x44,0x1e,0x32,0x42,0xbe,0x59,0xd1,0xc6,0xf4,0xfe,0x5e,0xe4,0xe6,0xd6,0x9c,0x42,0xcc,0x64,0x47,0x5e,0x61,0xbd,0xfe,0x05,0x0e,0x42,0x3a,0xbf,0x63,0xba,0xf3,0x85,0x5e,0x87,0x1e } };

#define NUMBER_OF_CERTS sizeof(at_certs) / sizeof(at_certs[0])

static sha_digest_t 		     at_cert_digest[NUMBER_OF_CERTS + 1] = { SHA_DIGEST_INIT };


static const uint8_t at_prKeys[][32] = {
        { 0x6b,0xd0,0x04,0xd8,0x96,0xb1,0x1d,0x5b,0x01,0x12,0xad,0x53,0x12,0xf9,0xb1,0x74,0x02,0x91,0xdc,0x57,0x63,0xce,0x97,0x6e,0x13,0xee,0xd0,0x27,0x9c,0xce,0xbb,0x80 },
        { 0x24,0x53,0xc1,0x20,0x7b,0xf4,0xe7,0x85,0xd6,0x28,0x12,0x35,0xe6,0x87,0x19,0x98,0x54,0x83,0xbb,0x01,0xee,0x19,0xff,0xaa,0x6a,0x2a,0x08,0x56,0xd9,0x85,0x54,0x07 },
        { 0x19,0xc4,0xe8,0x52,0x7a,0x75,0x24,0x46,0xd0,0x9b,0xfb,0x0e,0x6c,0x7b,0xeb,0xed,0x32,0xcb,0xa1,0x3c,0x53,0x3c,0x75,0xba,0x4b,0x49,0x72,0xf7,0x6a,0x3b,0x4d,0x89 },
        { 0x5f,0xaa,0x6f,0x46,0x5b,0x16,0x66,0x6b,0x76,0x1a,0x99,0x58,0xaf,0xcb,0xc2,0xdc,0xd1,0x3c,0xf5,0x87,0x51,0x03,0xea,0x4c,0x1b,0x37,0xa8,0xe6,0xa2,0xc9,0xdd,0x03 },
        { 0xce,0x87,0xe0,0x0b,0x59,0x9a,0x9f,0x16,0xae,0x20,0x8c,0xbc,0x92,0xc5,0xab,0x75,0x7d,0x19,0x39,0x6a,0x97,0x9b,0x87,0xf4,0xab,0xb9,0x53,0x83,0xdc,0x5d,0x4a,0x1a },
        { 0x4a,0x61,0x13,0xe0,0xf8,0xcf,0x6e,0xe0,0x92,0x9b,0x92,0xf0,0xa5,0x74,0x89,0xed,0x2b,0xa0,0x78,0x70,0xd5,0x32,0xb4,0xc9,0xf5,0xa7,0xed,0xcd,0xeb,0x77,0x83,0xca },
        { 0xc8,0x55,0xe6,0x18,0x1e,0x58,0x98,0xe8,0xa6,0x2e,0xea,0x9b,0x52,0x0b,0x6d,0xfd,0x9d,0x2e,0xc0,0xc8,0x97,0x9d,0x96,0xe0,0x56,0x26,0xe3,0xff,0xe2,0x6e,0x01,0xd7 },
        { 0x82,0x0b,0xdc,0x11,0xb1,0x46,0x8f,0x72,0x4d,0x08,0x58,0x92,0x1d,0x9a,0x19,0x5c,0x97,0xbf,0x41,0x0d,0xce,0xc7,0x92,0xb1,0x49,0xf4,0x73,0xd4,0xda,0x13,0x32,0x4a },
        { 0xb3,0x86,0xb4,0x97,0xf7,0xc1,0x4c,0x88,0x96,0x21,0xe7,0x9c,0x44,0xfb,0xa2,0x72,0x53,0x26,0xb5,0xe2,0xed,0x8d,0x23,0x07,0x54,0x02,0x87,0x46,0xd7,0x8a,0x54,0x67 },
        { 0x77,0x62,0x01,0x54,0x39,0x98,0x16,0xdc,0x47,0xfc,0xbd,0x7a,0x0e,0xfe,0x12,0x8a,0xc8,0x2f,0xba,0x8a,0x43,0xc5,0x5c,0x92,0xe7,0x74,0x34,0x6e,0x4a,0xbe,0x9d,0xf3 },
        { 0xa7,0xfc,0x79,0x67,0x1a,0x41,0x09,0xae,0x9d,0xbb,0xa5,0x5d,0xea,0xd0,0xf3,0x76,0xfb,0x3a,0x30,0x07,0x4f,0x76,0x15,0x88,0x7c,0xc7,0x73,0xff,0x23,0x4c,0xe7,0xc5 } };
  


//static const char at_prKey[] = { 0x3b,0x85,0x79,0xea,0x67,0x99,0x46,0xf0,0x28,0xd9,0x69,0xcc,0x64,0xe4,0x30,0xf7,0xb2,0x82,0x1f,0x5f,0xfb,0x97,0x2c,0x26,0x04,0x33,0x3a,0xd0,0xef,0x70,0x09,0xdd};

static const uint8_t at_full_chain[] = { 0x02,0x00,0x05,0x01,0x01,0x01,0x81,0xbb,0x80,0x03,0x81,0xab,0x01,0x09,0x01,0x83,0xca,0x21,0x68,0xb7,0x84,0xfc,0x6c,0x02,0x10,0x50,0x69,0x6c,0x6f,0x74,0x50,0x4b,0x49,0x5f,0x50,0x43,0x41,0x5f,0x53,0x49,0x54,0x80,0x91,0x00,0x00,0x04,0x0d,0x46,0x61,0xbf,0x77,0xf6,0x71,0x71,0x6e,0xa7,0x4e,0xa4,0xcd,0x92,0xef,0x5a,0x45,0x66,0xbe,0xea,0x66,0x81,0xed,0x04,0x4b,0x09,0xc3,0x1e,0xa4,0x7d,0x42,0xb3,0x88,0x93,0x2a,0x9b,0x2d,0xa9,0x57,0xf3,0xfd,0x2e,0x12,0x56,0xda,0xc8,0x06,0x9b,0x15,0x44,0xbf,0x29,0x88,0xd4,0x3e,0xf0,0x9b,0x8a,0xab,0xc6,0x78,0x13,0x46,0x5e,0x01,0x01,0x00,0x04,0x33,0x61,0xe7,0x3d,0xff,0x9b,0xc8,0x9c,0x42,0xf4,0x54,0x2a,0xac,0x7f,0xdd,0x9a,0x5a,0xba,0x66,0x53,0x10,0x87,0xd1,0xc3,0x1c,0x5a,0x95,0xb6,0x78,0x8e,0x06,0xbc,0x08,0xf9,0x40,0x2d,0x3e,0xd4,0x75,0x6a,0x6f,0xb0,0x69,0x37,0xf2,0xa9,0x19,0x83,0x38,0x41,0x35,0x8d,0x05,0x2f,0xb6,0xc9,0xaf,0x4c,0xc1,0xf6,0x84,0xc3,0xb7,0x6a,0x02,0xe0,0x20,0x06,0xc0,0x40,0x80,0xc0,0x40,0x81,0x0b,0x01,0x05,0xa4,0xec,0x01,0x10,0xec,0x21,0x01,0x03,0x00,0x00,0x00,0xc6,0x4e,0x89,0xa2,0x35,0x28,0xf5,0x0d,0x8a,0xf8,0x53,0x62,0x90,0xfe,0x9e,0x78,0xcc,0x26,0xf5,0x1d,0x6b,0x42,0x78,0xec,0x08,0x63,0x83,0xa4,0xaf,0xea,0xba,0x96,0x1a,0xd3,0x8a,0x2f,0xb2,0x86,0xd0,0xf0,0x75,0xde,0xdb,0x0c,0x79,0x29,0x96,0x0d,0x35,0x86,0x5e,0x80,0xa3,0xa0,0x22,0xca,0xc7,0x72,0xf1,0xda,0xca,0x6f,0x87,0x5a,0x01,0x09,0x01,0xa8,0xed,0x6d,0xf6,0x5b,0x0e,0x6d,0x6a,0x01,0x00,0x51,0x00,0x00,0x04,0x96,0x5e,0xdb,0xf7,0x48,0xa9,0xa1,0x35,0x8e,0x49,0x1d,0xd4,0xee,0xd8,0xe4,0xac,0xb2,0x6e,0x80,0xb7,0x48,0x9b,0x0b,0x38,0xb8,0x8b,0x72,0x4f,0x6d,0x32,0xb7,0xe1,0x16,0x2b,0x89,0xa6,0x8c,0xc9,0xa2,0xad,0xf0,0xfe,0x15,0xae,0x39,0x36,0x2a,0xf3,0x9b,0x67,0x6b,0xa2,0xb5,0x68,0x40,0x30,0x1e,0x1d,0xa3,0x49,0x09,0x81,0xa0,0xfd,0x02,0xe0,0x21,0x0a,0xc0,0x40,0x80,0x01,0x00,0xc0,0x40,0x81,0x01,0x00,0x0b,0x01,0x06,0xbc,0x6a,0x01,0x07,0x82,0x2b,0x00,0x03,0x00,0x00,0x00,0x77,0xfb,0x8e,0x6c,0x6d,0xe6,0xd6,0x83,0xc8,0x7a,0x2a,0xb1,0xee,0x5d,0x36,0x87,0xcc,0x9c,0xa4,0xf8,0xed,0x10,0x21,0x47,0x10,0xfe,0x25,0x42,0x20,0x95,0x5d,0xed,0xb9,0xa0,0x81,0x07,0x76,0xc1,0xb8,0x49,0xa9,0x6a,0xbf,0x79,0x5a,0xca,0x2c,0xc0,0x10,0x85,0x86,0x0d,0x9c,0xd3,0x40,0x5d,0x67,0x38,0x9b,0xda,0x6c,0xb4,0xd7,0x27,0x00,0x00,0x00,0x83,0xac,0x10,0x3e,0x4d,0x20,0x05,0x00,0x02,0x54,0x01,0x52,0x20,0x50,0x02,0x80,0x00,0x2e,0x01,0x00,0x01,0x01,0x90,0x56,0x92,0x00,0x00,0xe1,0xcd,0xb7,0x65,0x53,0x19,0x16,0xc9,0x12,0x14,0x3b,0xec,0x38,0x1d,0xae,0x0d,0xbc,0x00,0x00,0x00,0x00,0x07,0xd1,0x00,0x00,0x01,0x02,0x92,0x00,0x00,0xe1,0x65,0x53,0x00,0x09,0xd7,0x76,0x42,0x4f,0xf0,0xb7,0xc6,0xff,0xff,0xff,0xfc,0x21,0xf8,0x64,0x53,0xbc,0x07,0x6f,0x3f,0x3b,0x5d,0xf8,0xff,0x8f,0x68,0x39,0xba,0x98,0x79,0xff,0xfe,0x80,0x43,0x01,0x00,0x00,0x42,0xba,0x82,0x25,0x41,0xbb,0xef,0xd2,0x83,0x76,0xcf,0x0a,0x68,0x24,0x10,0xf4,0xe5,0xf0,0x62,0x7c,0x1f,0x72,0x64,0x5d,0x46,0x29,0x09,0x70,0xe8,0x9e,0xb0,0xdb,0xfa,0x47,0x59,0x9d,0xae,0xf0,0x02,0x72,0xad,0xf5,0xb4,0xfb,0xac,0x7f,0xcc,0xb8,0x7f,0xdd,0xe5,0x2d,0x09,0x83,0x8c,0x89,0x26,0x2c,0xf5,0x17,0x9c,0xf7,0x2d,0x7e };

static const uint8_t full_cert_hash3[] = { 0x04, 0x06, 0x0e, 0x6d, 0x6a, 0x96, 0x84, 0x73 };


/* TX thread */
static TX_THREAD tg_tx_thread_hwd;
static uint8_t tg_tx_thread_stack[TG_THREAD_STACK_SIZE];
void tg_tx_thread(ULONG input);

/* RX thread */
static TX_THREAD tg_rx_thread_hwd;
static uint8_t tg_rx_thread_stack[TG_THREAD_STACK_SIZE];
void tg_rx_thread(ULONG input);

/* Statistics thread */
static TX_THREAD tg_stats_thread_hwd;
static uint8_t tg_stats_thread_stack[TG_STAT_THREAD_STACK_SIZE];
void tg_stats_thread(ULONG input);



/* This thread is to receive everthing on the V2X RX so buffers will not be loaded */	
void tg_rx_thread(ULONG input)
{
  /* Autotalks return code */
  atlk_rc_t rc = ATLK_OK;
  /* Not using input */
  (void)input;

  while (1) {
	
    char rx_buf[1000];
    size_t size = sizeof(rx_buf);
    v2x_receive_params_t receive_params = V2X_RECEIVE_PARAMS_INIT;

    /* Receive frame (wait forever until it arrives) */
    rc = v2x_receive(v2x_socket, rx_buf, &size, &receive_params, &atlk_wait_forever);
    if (atlk_error(rc)) {
      fprintf(stderr, "v2x_receive: %s\n", atlk_rc_to_str(rc));
    }
		else {
 			counters[RX_COUNTER]++;
		}
	}

}


int create_packet_signeture(const uint8_t *data , uint32_t data_size,  const uint8_t *private_key, ecdsa_signature_t *signature )
{
  atlk_rc_t 			        rc 			        = ATLK_OK;
  ecc_signing_request_t   request         = ECC_SIGNING_REQUEST_INIT;
	ecc_signing_response_t  response        = ECC_SIGNING_RESPONSE_INIT;
  sha_digest_t 		        digest 	        = SHA_DIGEST_INIT;
  ecdsa_signature_t       sign            = ECDSA_SIGNATURE_INIT;

  if ( (data == NULL) || (signature == NULL) ) {
    fprintf(stderr, "Error parameter" );
    return -1;
  }

  // *signature = ECDSA_SIGNATURE_INIT;
  
	/* Compute SHA-256 hash value of GN standard frame*/
  rc = sha_hw_sha256_compute(data, data_size, &digest);
  if (atlk_error(rc)) {
    fprintf(stderr, "sha_hw_sha256_compute: %s", atlk_rc_to_str(rc));
    return rc;
  }

  // printf( SHA_DIGEST_FMT "\n", SHA_DIGEST_FMT_ARGS(digest) );

	request.request_id = 1;
	request.curve = ECC_CURVE_P256;

  fmt_os2ip( private_key, request.private_key.value, 8);
  
  //memcpy ( request.private_key.value , at_prKey, 32);
  
  memcpy( &request.digest, &digest, sizeof(digest) );

	rc = ecc_signing_request_send ( ecc_sign_socket, &request, NULL );
  if (atlk_error(rc)) {
    fprintf(stderr, "ecc_signing_request_send: %s\n", atlk_rc_to_str(rc));
    return rc;
  }

	rc = ecc_signing_response_receive ( ecc_sign_socket, &response, &atlk_wait_forever );
  if (atlk_error(rc)) {
    fprintf(stderr, "ecc_signing_response_receive: %s\n", atlk_rc_to_str(rc));
    return rc;
  }
  
  /* Print generated ECDSA signature */  
  /*
    printf("ECDSA signature generated:\n"); 
    printf("  Rx: " ECC_SCALAR_FMT "\n",    ECC_SCALAR_FMT_ARGS(response.signature.R_point.x_coordinate));
    printf("  Ry: " ECC_SCALAR_FMT "\n",    ECC_SCALAR_FMT_ARGS(response.signature.R_point.y_coordinate));
    printf("  s: " ECC_SCALAR_FMT "\n",    ECC_SCALAR_FMT_ARGS(response.signature.s_scalar));
  */
  
  /* Convert ECDSA signature for fast verification */
  rc = ecdsa_signature_convert(request.curve, &response.signature, &sign);
  if (atlk_error(rc)) {
    fprintf(stderr, "ecdsa_signature_convert: %s\n", atlk_rc_to_str(rc));
    return rc;
  }  

  fmt_i2osp( sign.r_scalar.value, (uint8_t *) signature->r_scalar.value, 8);
  //*** TBD fmt_i2osp( sign.s_scalar.value, (uint8_t *) signature->s_scalar.value, 8);
  
  /* Print converted ECDSA signature for fast verification */
  /*
    printf("Converted ECDSA signature for fast verification:\n");
    printf("  r: " ECC_SCALAR_FMT "\n", ECC_SCALAR_FMT_ARGS(signature.r_scalar));
    printf("  s: " ECC_SCALAR_FMT "\n", ECC_SCALAR_FMT_ARGS(signature.s_scalar));
  */
	return 0;
}


int get_nav_info( void ) {

	
	atlk_rc_t 						rc;
	struct timeval 				tv;
	
	/* Get current fix */
	rc = nav_fix_receive(nav_subscriber, &nav_fix, NULL);
	if (atlk_error(rc)) {
		// printf( "NOTE : nav_fix_receive failed in fill_source_position_vector : %s\n", atlk_rc_to_str(rc));
	}

	if ( isnan( nav_fix.position_latitude_deg ) ) {

    nav_fix.position_longitude_deg = htonl(1800000001);
    nav_fix.position_longitude_deg = htonl(900000001);
    nav_fix.movement_horizontal_direction_deg = (int16_t) htons( 3600 );
    nav_fix.movement_horizontal_speed_mps = (int16_t) htons( 16383 );
    nav_fix.time.tai_seconds_since_2004 = 189388800; /* set it 01/01/2010 as defualt */
  }

	// gettimeofday(&tv, NULL);
	// nav_fix.time.tai_seconds_since_2004 = (tv.sec - 1072915200.0)

	return 0;

}


/* Create GeoNetworking Layer */

int fill_source_position_vector( spv_t *spv, eui48_t mac ) 
{
  atlk_rc_t             rc;
  
  /* Get current fix */
	rc = nav_fix_receive(nav_subscriber, &nav_fix, NULL);
	if (atlk_error(rc)) {
		// printf( "NOTE : nav_fix_receive failed in fill_source_position_vector : %s\n", atlk_rc_to_str(rc));
	}

	if ( !isnan( nav_fix.position_latitude_deg ) ) {

		spv->latitude = htonl( CONVERT_LAT_LNG(nav_fix.position_latitude_deg) );
		spv->longitude = htonl( CONVERT_LAT_LNG(nav_fix.position_longitude_deg) );
		spv->time_stamp  = htonl( (uint32_t) ( (uint64_t) (nav_fix.time.tai_seconds_since_2004 * 1000.0) ) );
		spv->heading =  (int16_t) htons( (int16_t) (nav_fix.movement_horizontal_direction_deg * 10.0) );
		spv->speed =  (int16_t) htons( (int16_t) ( (nav_fix.movement_horizontal_speed_mps * 100.0) ) );
	}
  else {
    spv->longitude = htonl( 1800000001 );
    spv->latitude = htonl(900000001);
    spv->heading = (int16_t) htons( 3600 );
    spv->speed = (int16_t) htons( 16383 );
    spv->time_stamp = 189388800;
    // nav_fix.time.tai_seconds_since_2004 = 189388800; /* set it 01/01/2010 as defualt */
  }

  memcpy( spv->gn_addr.link_addr, mac.octets, sizeof(mac) );

  spv->pai = 0x1;
  spv->gn_addr.d1 = 0x1;
  spv->gn_addr.d2 = 0x1;

  return 0;

}

int create_gn_layer( gn_t *gn , eui48_t mac )
{
  atlk_rc_t             rc;

  memset ( gn, 0 , sizeof(gn_t) );
  memcpy( gn->tsb.spv.gn_addr.link_addr, mac.octets, sizeof(mac) );

  /* Fill Basic Header */
  gn->basic_header.version = 0x0;

  /* Unsecured frame next */
  gn->basic_header.next_hdr = 0x1;

  gn->basic_header.reserved = 0x0;
  gn->basic_header.lifetime = 0x05;
  gn->basic_header.hop_limit = 0x1;

  /* Fill commond header */
  gn->common_header.next_header = 0x2;
  gn->common_header.reserved= 0x0;
  gn->common_header.header_type = 0x05;
  gn->common_header.hst = 0x0;
  gn->common_header.traffic_class = 0x02;
  gn->common_header.flags = 0x80;
  gn->common_header.maximum_hop_limit = 0x1;

  /* Get current fix */
  fill_source_position_vector( &gn->tsb.spv , mac );
  
	gn->tsb.spv.gn_addr.link_addr[4] = station_id;

  return 0;

}



int copy_security_header ( signing_opt_t sign_frame, sh_profile_t profile, uint32_t cert_id,
                            uint8_t **pos,  secure_header_t *secure_header )
{

  /* Load security header of gn is security exists */
	if ( sign_frame ) {
    
    if ( sign_frame & SIGN_DIGEST ) { 
      /* Copy header of secure trailer until header_fields --> 3 bytes */
  		memcpy( *pos, secure_header , 5  );  *pos += 5;

      /* Copy digest / Cert */
  		memcpy( *pos, secure_header->header_fields.certificate , HASH_ID8_SIZE  );  *pos += HASH_ID8_SIZE;
      
    }
    else {

      /* Copy header of secure trailer until header_fields --> 3 bytes */
  		memcpy( *pos, secure_header , 2  );  *pos += 2;

      // printf( "secure_header.header_length is %u\n", secure_header.header_length);
      uint16_t hdr_length = htons( secure_header->header_length + 0x8000 );

      /* Modify the length to support full chain */
      if ( sign_frame & SIGN_WITH_CHAIN ) {
        hdr_length = htons ( HDR_FIELDS_SIZE + sizeof(at_certs[cert_id]) + sizeof(aa_cert) + 2 /* Full chain size */ + 0x8000 );
      }
      
      memcpy( *pos, &hdr_length , 2  );  *pos += 2;

      /* Copy header of secure trailer until header_fields --> 3 bytes */
  		memcpy( *pos, &secure_header->header_fields.signer_info, 2  );  *pos += 2;

      if ( sign_frame & SIGN_WITH_CHAIN ) {
        uint16_t  tmp = htons( sizeof(at_certs[cert_id]) + sizeof(aa_cert) + 0x8000  ); //  htons(0x81ab);
        /* Copy header of secure trailer until header_fields --> 3 bytes */
  		  memcpy( *pos, &tmp, 2  );  pos += 2;
      }

      if ( sign_frame & SIGN_WITH_CHAIN ) {
        /* Copy full certificate */
        memcpy( *pos, aa_cert, sizeof(aa_cert)  );  *pos += sizeof(aa_cert);
      }
      
      /* Copy full certificate */
  		memcpy( *pos, at_certs[cert_id], sizeof(at_certs[cert_id])  );  *pos += sizeof(at_certs[cert_id]);

    }

    /* Copy generation time header fiels */
    // memcpy( *pos, &secure_header.header_fields.hdr_generation_time, 12  );  *pos += 12;

    memcpy( *pos, &secure_header->header_fields.hdr_generation_time, sizeof(uint8_t)  );  *pos += sizeof(uint8_t);
		
    memcpy( *pos, &secure_header->header_fields.generation_time.value, sizeof(uint64_t)  );  *pos += sizeof(uint64_t);

    if ( profile == DENM_FRAME ) {
      memcpy( *pos, secure_header->header_fields.generation_location, sizeof(generation_loc_t) ); *pos += sizeof(generation_loc_t) ;
      // memcpy( *pos, &secure_header->header_fields.generation_location., 1  ); *pos += 9;
    }

    /* Copy last header fields */
    memcpy( *pos, &secure_header->header_fields.header_field, 3  );  *pos += 3;
    
    if ( sign_frame & SIGN_WITH_CHAIN ) {
      // memcpy( *pos, full_cert_hash3 , sizeof(full_cert_hash3)  );  *pos += sizeof(full_cert_hash3);
    }
    
    /* Copy secure header footer */
		memcpy( *pos, &secure_header->payload_length , 3  );  *pos += 3;

    if ( secure_header->header_fields.certificate != NULL ) {
      free(secure_header->header_fields.certificate);
    }

	}


  return 0;
}


int create_secure_header ( signing_opt_t sign_frame, sh_profile_t profile, uint32_t cert_id,
                            uint32_t pdu_size,  secure_header_t *secure_header, uint32_t *msg_size )
{
  //   secure_header_t		secure_header;
  uint32_t  sec_hdr_size = 0, sec_flds_size = 0, size = 0;
  int32_t   payload_len = 0 ;

  if ( secure_header == NULL ) {
    return (-1);
  }

  /* Remove pointer sizes from size calculations */
  sec_flds_size =  sizeof(header_fields_t) - sizeof(uint8_t*) - sizeof(generation_loc_t*);

  if ( profile == DENM_FRAME ) { 
    sec_flds_size += sizeof(generation_loc_t);
    secure_header->header_fields.generation_location = calloc( sizeof(generation_loc_t), sizeof(uint8_t) );
    secure_header->header_fields.generation_location->header = HDR_GENERATION_LOCATION;
  }

  sec_hdr_size = sizeof(secure_header_t) - sizeof(header_fields_t) + sec_flds_size;

  // printf( "sec_hdr_size is %u, sec_flds_size is %u\n", sec_hdr_size, sec_hdr_size );

  if ( sign_frame ) {

    secure_header->version = 0x1; 
		if ( profile == CAM_FRAME ) {
      secure_header->profile = 0x1;
    }
    else if ( profile == DENM_FRAME ) {
      secure_header->profile = 0x2;
    }
		

    /* Create header files for cam */
    
    if ( sign_frame & SIGN_WITH_CHAIN ) {

      uint8_t   *certificate_pos  = NULL;
      
      secure_header->header_length = sec_flds_size + sizeof(at_certs[cert_id]) + sizeof(aa_cert);
      secure_header->header_fields.sign_info_type = 0x3;
      secure_header->header_fields.certificate = calloc( sizeof(aa_cert) + sizeof(at_certs[cert_id]), sizeof(uint8_t) );

      /* Copy all certificates to memory */
      certificate_pos = secure_header->header_fields.certificate;
			memcpy( certificate_pos, aa_cert, sizeof(aa_cert) );
      certificate_pos += sizeof(aa_cert);
			memcpy( certificate_pos, at_certs[cert_id], sizeof(at_certs[cert_id]) );
      
      size += sizeof(signature_trailer_t) + sec_hdr_size + sizeof(at_certs[cert_id]) + sizeof(aa_cert) + 1 /* size of header change to 2 bytes */ + 2  /* Size for certificates */;  //+ sizeof(full_cert_hash3);
    }
    else if ( sign_frame & SIGN_CERTIFICATE ) {

      secure_header->header_length = sec_flds_size + sizeof( at_certs[cert_id] );
      // printf( "secure_header->header_length is %u, calc is %u\n", secure_header->header_length, ( sizeof(header_fields_t) - sizeof(uint8_t*) + sizeof(at_cert) )  );
      secure_header->header_fields.certificate = calloc( sizeof(at_certs[cert_id]), sizeof(uint8_t) );
      secure_header->header_fields.sign_info_type = 0x2;
      
  		/* Copy last 8 bytes from entire digest */
			memcpy( secure_header->header_fields.certificate, at_certs[cert_id], sizeof(at_certs[cert_id]) );

      size += sizeof(signature_trailer_t) + sec_hdr_size + sizeof( at_certs[cert_id] ) + 1 /* size of header change to 2 bytes */;
      
    }
    else if ( sign_frame & SIGN_DIGEST ) {
      
      /* Send digest value */
      secure_header->header_length = sec_flds_size + HASH_ID8_SIZE;
      secure_header->header_fields.certificate = calloc( HASH_ID8_SIZE, sizeof(uint8_t) );
      
  		/* Copy last 8 bytes from entire digest */
			memcpy( secure_header->header_fields.certificate, &at_cert_digest[cert_id].value[ ( sizeof(sha_digest_t) - HASH_ID8_SIZE ) ], HASH_ID8_SIZE );
      
      secure_header->header_fields.sign_info_type = 0x1;
      
      size += sizeof(signature_trailer_t) + sec_hdr_size + HASH_ID8_SIZE;
    }

		/* Security header */
		secure_header->header_fields.signer_info= HDR_SIGNER_INFO;

    /* Get generation time */
		secure_header->header_fields.hdr_generation_time = HDR_GENERATION_TIME;
		// hdr_flds.generation_time.value = ntohll( ( (uint64_t) (nav_fix.time.tai_seconds_since_2004 * 1000000.0) - 189388800000000 ) );
		secure_header->header_fields.generation_time.value = ntohll( (uint64_t) (nav_fix.time.tai_seconds_since_2004 * 1000000.0) - 189388800000000 );

    payload_len = sizeof(uint32_t) /* btp header */ + pdu_size + sizeof(common_header_t);
    
    secure_header->header_fields.header_field = HDR_MESSAGE_TYPE;
    if ( profile == CAM_FRAME ) {
      secure_header->header_fields.message_type = htons( 0x2 );
      payload_len += sizeof(tsb_t);
    }
    else if ( profile == DENM_FRAME ) {
      secure_header->header_fields.message_type = htons( 0x1 );
      payload_len += sizeof(gbc_t);
    }

    secure_header->payload_data_length = payload_len;
    secure_header->payload_length = secure_header->payload_data_length + 2;
    secure_header->payload_type = 0x1;

  }

  *msg_size += size;
  
  return 0;
  
}


int create_cam_packet( uint8_t **packet, uint32_t *packet_size, signing_opt_t sign_frame, uint32_t cert_id, eui48_t mac, uint32_t station_id )
{

  atlk_rc_t         rc;
	uint8_t           *buffer = NULL, *pos = NULL;
	uint32_t	        msg_size = 0;
	size_t            pdu_size = 0;
	
	uint8_t	          btp_data[] = {0x07, 0xd1,  0x00, 0x00};
  uint32_t          frm_sequence_num = 0;

  gn_t              gn;
	secure_header_t		secure_header;
  sh_profile_t      profile = CAM_FRAME;
  


  rc = nav_fix_receive(nav_subscriber, &nav_fix, NULL);

  rc = create_gn_layer( &gn , mac );

  
	rc = create_cam_layer( nav_fix, station_id, &buffer , &pdu_size );
  if ( rc != 0 ) {
    printf( "ERROR : build_cam_frame failed with error value %d\n", rc );
  }

	/* Update GN payload Length */
	gn.common_header.payload_length = htons( sizeof(btp_data) + pdu_size );
  msg_size = sizeof(gn_t) + sizeof(btp_data) + pdu_size;


  if ( sign_frame ) {

    /* Update gn header is security is enabled */
    gn.basic_header.next_hdr = 0x2;
    rc = create_secure_header ( sign_frame, profile, cert_id, pdu_size,  &secure_header, &msg_size );
    if ( rc != 0 ) {
      printf( "ERROR : create_secure_header failed\n");
    }
  }

  // printf( "Frame signed %d ?, msg size before %u, after %u\n", sign_frame, tmp_size, msg_size );
  
  *packet = calloc( msg_size , sizeof( uint8_t ) );
  pos = *packet;

	/* Load Common basic header */
	memcpy( pos, &gn.basic_header , sizeof(basic_header_t) );
	pos += sizeof(basic_header_t);

  
  if ( sign_frame ) {
    rc = copy_security_header ( sign_frame, profile, cert_id, &pos,  &secure_header );
    if ( rc != 0 ) {
      printf( "ERROR : copy_security_header failed with rc = %d\n", rc );
    }
  }

  /* Start build of frames */
  
	/* Copy Common header of GN */
	memcpy( pos, &gn.common_header , sizeof(common_header_t) );
	pos += sizeof(common_header_t);
	
	/* Copy tsb header of GN */
	memcpy( pos, &gn.tsb , sizeof(tsb_t) );
	pos += sizeof(tsb_t);
	
	/* Load BTP data */
	memcpy( pos, &btp_data , sizeof(btp_data) );
  pos += sizeof(btp_data); 
	
	/* Copy CAM data */
	memcpy( pos, buffer , pdu_size );
  pos += pdu_size;
  
  /* Add the security trailer */		
  if ( sign_frame ) {
    signature_trailer_t       st;
    uint8_t                   *sign_pos = NULL;
    
		uint32_t sign_data_len = msg_size - sizeof(basic_header_t) - sizeof(signature_trailer_t);
    // printf( "msg_size : %u, sign_data_len is %u\n, offset from start %u ", msg_size, sign_data_len, sizeof(basic_header_t) );

    st.length = 67;
    st.type = 0x1;
    st.signature.ecc_point_type = 0x0;
    st.signature.pka = 0x0;

    memcpy( pos, &st , 2);

    sign_pos = *packet;
    sign_pos += sizeof(basic_header_t);

    rc = create_packet_signeture( (const uint8_t *) sign_pos , (sign_data_len + 2), at_prKeys[cert_id], &st.signature.ecdsa_sign);
    if ( rc != 0 ) {
      printf( " ERROR : sign_frame failed" );
      return (-1);
    }

    memcpy( pos, &st , sizeof(signature_trailer_t) );
    pos += sizeof(st); 
    
  }    

  *packet_size = (uint32_t) msg_size;

	return 0;
}


int tg_tx_complex( eui48_t mac  )
{
  static uint8_t    send_certificate = 1;
  atlk_rc_t         rc;
	v2x_send_params_t link_sk_tx_param = V2X_SEND_PARAMS_INIT;
  int32_t           i, j,frame_type;

	uint8_t           *hex_arr = NULL; 
	uint32_t	        msg_size = 0, cycle_time= 0, start_time = 0;
  uint32_t          cert_id = 0;
  signing_opt_t     sign_frame;

  send_certificate = !(send_certificate);
  start_time = tx_time_get();

  for ( i = 0; i < TOTAL_FRM_TYPES; i++ ) {
    
    frame_type = i;
    for ( j = 0; j < tx_frames[frame_type]; j ++ ) {

      if ( sec_active ) {
        
        sign_frame = SIGN_DIGEST; 

        if ( send_certificate ) {
          sign_frame = SIGN_CERTIFICATE;  
        }

        if ( frame_type == NOT_SIGNED_FRAME ) {
          sign_frame = SIGN_DISABLE;
        }
        else if ( frame_type == BAD_SIGNED_FRAME ) {
          sign_frame |= SIGN_WITH_ERROR;
        }
        
      }
      else {
        sign_frame = SIGN_DISABLE;
      }

      /* Update the mac address */
      mac.octets[4] = station_id;

      cert_id = station_id % NUMBER_OF_CERTS;

      if ( frame_type != DENM_FRAME ) {
        
        rc = create_cam_packet( &hex_arr, &msg_size, sign_frame, cert_id, mac, station_id );
        if ( rc != 0 ) {
          printf ( "ERROR : CAM packet create failed\n");
        }
  			counters[CAM_TX_COUNTER]++;

      }
      else if ( frame_type == DENM_FRAME ) {
        
        rc = create_denm_packet( &hex_arr, &msg_size, sign_frame, cert_id, mac, station_id );
        if ( rc != 0 ) {
          printf("ERROR : create_denm_packet failed, rc %d\n", rc );
        }
  			counters[DENM_TX_COUNTER]++;

      }

  		/* Set mac addr to simulate diffrent cars */
  		rc = mib_set_wlanMacAddress(mib_service, 1, mac);
  		
  		rc = v2x_send(v2x_socket, hex_arr, msg_size, &link_sk_tx_param, NULL);
  		if ( atlk_error(rc) != ATLK_OK ) {
  			// printf( " ERROR : v2x_send failed !! with error %d\n" , rc );
        tx_thread_sleep (3);
  		}
  		else {
  			counters[TX_COUNTER]++;
  		}
      
  		if ( hex_arr != NULL ) {
  			free( hex_arr );
  		}	


      /* Update all station Id, Geo address information. */
      if ( ++station_id > stations_simulated ) {
        station_id = 0;
      }


      uint32_t sleep_time = (uint32_t) ( floor(1000.0 / (double) frame_rate) );
      if ( counters[TX_COUNTER] % 5 ) {
        sleep_time = (uint32_t) ( ceil(1000.0 / (double) frame_rate) );
      }

    }

  }



}


void tg_tx_thread( ULONG input )
{
  atlk_rc_t         rc;
	uint32_t	        cycle_time= 0, start_time = 0;

	eui48_t	          mac = { .octets = {0x0, 0x01, 0x2,  0x3, 0x4, 0x5} };



 	rc = mib_get_wlanMacAddress(mib_service, 1, &mac);

	while (1) {
    
    /* Pause TG traffic */
    if ( tg_frame_sleep == 0 ) {
      tx_thread_sleep(1000);
      continue;
    }

    start_time = tx_time_get();
    
    tg_tx_complex( mac );
    
    /* sleep the rest of the cycle */
    
    cycle_time = ( tx_time_get() - start_time );
    // printf ( "Start time %u , current time %u, cycle time %u\n", start_time, tx_time_get(), cycle_time );
    if ( (1000 - cycle_time) > 0 ) {
      tx_thread_sleep( (1000 - cycle_time) );
    }
    
    
		
	}
	
	return;
}







int create_denm_packet( uint8_t **packet, uint32_t *packet_size, signing_opt_t sign_frame, uint32_t cert_id, eui48_t mac, uint32_t station_id )
{
  atlk_rc_t             rc;
	uint8_t	              *hex_arr = NULL, *buffer = NULL, *pos = NULL;
	uint32_t	            msg_size = 0;
	size_t                pdu_size = 0;

  gn_all_t              gn;
  spv_t                 *spv;

  static uint32_t    denm_seq_counter = 1;
	uint8_t	 btp_data[] = {0x07, 0xd2,  0x00, 0x00};

	secure_header_t		secure_header;

  sh_profile_t      profile = DENM_FRAME;


  /* Create GN layer for denm */
  /* Fill Basic Header */
  gn.basic_header.version = 0x0;
  /* Common header */
  gn.basic_header.next_hdr = 0x1;
  gn.basic_header.reserved = 0x0;
  gn.basic_header.lifetime = 0xf1;
  gn.basic_header.hop_limit = 0x9;

  /* Fill commond header */
  gn.common_header.next_header = 0x2;
  gn.common_header.reserved= 0x0;
  gn.common_header.header_type = 0x04;
  gn.common_header.hst = 0x2;
  gn.common_header.traffic_class = 0x00;
  gn.common_header.flags = 0x80;
  gn.common_header.maximum_hop_limit = 0xa;

  gn.types.gbc = calloc( 1, sizeof(gbc_t) );

  // msg_size = sizeof(gn_t) + sizeof(btp_data) + pdu_size;

  rc = nav_fix_receive(nav_subscriber, &nav_fix, NULL);
	if (atlk_error(rc)) {
		// printf( "NOTE : nav_fix_receive failed @ create_denm_packet : %s\n", atlk_rc_to_str(rc));
	}
	
	rc = create_denm_layer( nav_fix, station_id, &buffer , &pdu_size );

  msg_size = sizeof(gbc_t) + sizeof(basic_header_t) + sizeof(common_header_t) + sizeof(btp_data) + pdu_size;

  /* Update gn header is security is enabled */
  if ( sign_frame ) {

    /* Update gn header is security is enabled */
    gn.basic_header.next_hdr = 0x2;
    rc = create_secure_header ( sign_frame, profile, cert_id, pdu_size, &secure_header, &msg_size );
    if ( rc != 0 ) {
      printf( "ERROR : create_secure_header failed\n");
    }
  }
  
  spv = &gn.types.gbc->spv;
  rc = fill_source_position_vector( spv, mac );

  spv->gn_addr.link_addr[4] = station_id;



  if ( sign_frame ) {

    secure_header.header_fields.generation_location->header = HDR_GENERATION_LOCATION;
    secure_header.header_fields.generation_location->elevation = CONVERT_ALT(nav_fix.position_altitude_m);
    secure_header.header_fields.generation_location->latitude= CONVERT_ALT(nav_fix.position_altitude_m);
    secure_header.header_fields.generation_location->longitude= CONVERT_ALT(nav_fix.position_longitude_deg);
    
  }
  
  /* Update GN payload Length */
  gn.common_header.payload_length = htons( sizeof(btp_data) + pdu_size );
  gn.types.gbc->sequence_number = denm_seq_counter++; 

	// gn_info.geo_bc.gbc->sequence_number = denm_seq_cntr++;
	gn.types.gbc->latitude = spv->longitude;
	gn.types.gbc->longitude = spv->longitude;
	gn.types.gbc->distance_a = 100;
	gn.types.gbc->distance_b = 100;
	gn.types.gbc->angle = 0;
  gn.types.gbc->life_time = 0;

  
	
  /* Load GN data */
	*packet = calloc( msg_size , sizeof( uint8_t ) );
  pos = *packet; 

	/* Load Common basic header */
	memcpy( pos, &gn.basic_header , sizeof(basic_header_t) );
	pos += sizeof(basic_header_t);

  
  if ( sign_frame ) {
    rc = copy_security_header ( sign_frame, profile, cert_id, &pos,  &secure_header );
    if ( rc != 0 ) {
      printf( "ERROR : copy_security_header failed with rc = %d\n", rc );
    }

    if ( secure_header.header_fields.generation_location = NULL ) {
      free(secure_header.header_fields.generation_location);
    }
  }

  

	/* Copy Common header of GN */
	memcpy( pos, &gn.common_header , sizeof(common_header_t) );	pos += sizeof(common_header_t);
    
  memcpy( pos , gn.types.gbc , sizeof(gbc_t) );   pos += sizeof(gbc_t);
  
  /* Load BTP data */
  memcpy( pos, &btp_data , sizeof(btp_data) ); pos += sizeof(btp_data);
    
  /* Copy DENM data */
  memcpy( pos, buffer , pdu_size );  pos += pdu_size;

  if ( packet_size == NULL ) {
    printf( "ERROR : parameter is mismatch\n");
    return (-1);
  }
  

  *packet_size = msg_size;

   if ( sign_frame ) {
    signature_trailer_t       st;
    uint8_t                   *sign_pos = NULL;
    
		uint32_t sign_data_len = msg_size - sizeof(basic_header_t) - sizeof(signature_trailer_t);
    // printf( "msg_size : %u, sign_data_len is %u\n, offset from start %u ", msg_size, sign_data_len, sizeof(basic_header_t) );

    st.length = 67;
    st.type = 0x1;
    st.signature.ecc_point_type = 0x0;
    st.signature.pka = 0x0;

    memcpy( pos, &st , 2);

    sign_pos = *packet;
    sign_pos += sizeof(basic_header_t);

    rc = create_packet_signeture( (const uint8_t *) sign_pos , (sign_data_len + 2), at_prKeys[cert_id], &st.signature.ecdsa_sign);
    if ( rc != 0 ) {
      printf( " ERROR : sign_frame failed" );
      return (-1);
    }

    if ( sign_frame & SIGN_WITH_ERROR ) {
      st.signature.ecdsa_sign.r_scalar.value[0] != st.signature.ecdsa_sign.r_scalar.value[0];
    }
    

    memcpy( pos, &st , sizeof(signature_trailer_t) ); pos += sizeof(st); 
    
  }    

  if ( gn.types.gbc != NULL ) {
    free(gn.types.gbc);
  }

	return 0;
}


void send_full_certificate(void)
{
  atlk_rc_t         rc;
	v2x_send_params_t link_sk_tx_param = V2X_SEND_PARAMS_INIT;

  
  rc = v2x_send(v2x_socket, at_full_chain, sizeof(at_full_chain), &link_sk_tx_param, NULL);
  if ( atlk_error(rc) != ATLK_OK ) {
    printf( " ERROR : v2x_send failed !! with error %d\n" , rc );
  }

  return;
}


void tg_stats_thread(ULONG input)
{
  uint64_t    counter = 0;
  
	while (1) {
		print_counters();
		tx_thread_sleep(1000);
    send_full_chain = 0;
    
    if ( ((++counter % 10)== 0) && (send_full_chain_rate) ) {
      send_full_chain = 1;
	  }
    
	}
}

void print_counters( void ) 
{
  static uint32_t              last_counters[LAST_COUNTER] = { 0 };

  if ( !cntr_print )
		return;
  
		
	printf ( "STATS : Tx: %u (%lu)\tRx: %u (%u)\tCAM Tx: %u (%u)\tCAM Rx: %u\tDENM Tx: %u (%u)\t DENM Rx: %u (%u)\n", 
										counters[TX_COUNTER],
										(counters[TX_COUNTER] - last_counters[TX_COUNTER]),
										counters[RX_COUNTER],
										(counters[RX_COUNTER] - last_counters[RX_COUNTER]),
										counters[CAM_TX_COUNTER],
										(counters[CAM_TX_COUNTER] - last_counters[CAM_TX_COUNTER]),
										counters[CAM_RX_COUNTER],
										counters[DENM_TX_COUNTER],
										(counters[DENM_TX_COUNTER] - last_counters[DENM_TX_COUNTER]),
										counters[DENM_RX_COUNTER],
										(counters[DENM_RX_COUNTER] - last_counters[DENM_RX_COUNTER])  );

  last_counters[CAM_TX_COUNTER] = counters[CAM_TX_COUNTER];
  last_counters[CAM_RX_COUNTER] = counters[CAM_RX_COUNTER];
  
  last_counters[DENM_TX_COUNTER] = counters[DENM_TX_COUNTER];
  last_counters[DENM_RX_COUNTER] = counters[DENM_RX_COUNTER];

  last_counters[TX_COUNTER] = counters[TX_COUNTER];
  last_counters[RX_COUNTER] = counters[RX_COUNTER];
  
}

/* Setup CAN conncetion */
int tg_init()
{
  atlk_rc_t rc;
	uint32_t status;
	v2x_service_t 				*v2x_service = NULL;
	v2x_socket_config_t	  link_sk_params = V2X_SOCKET_CONFIG_INIT;

	
	// craton_rf_init();
	
  /* Init nav fix */
  rc = nav_default_service_get(&nav_service);
  if ( atlk_error(rc) != ATLK_OK ) {
    printf( " ERROR : nav_default_service_get failed !! with error %d\n" , rc );
  }


  rc = nav_fix_subscriber_create(nav_service, &nav_subscriber);
  if ( atlk_error(rc) != ATLK_OK ) {
    printf( " ERROR : nav_fix_subscriber_create failed !! with error %d\n" , rc );
  }
	
	rc = v2x_hw_service_get(&v2x_service);
  if ( atlk_error(rc) != ATLK_OK ) {
    printf( " ERROR : v2x_hw_service_get failed !! with error %d\n" , rc );
  }

	

	link_sk_params.if_index = 1;
	link_sk_params.protocol.frame_type = V2X_FRAME_TYPE_DATA;
	link_sk_params.protocol.protocol_id = 0x8947;
	
	rc = v2x_socket_create(v2x_service, &v2x_socket, &link_sk_params);
  if ( atlk_error(rc) != ATLK_OK ) {
    printf( " ERROR : v2x_socket_create failed !! with error %d\n" , rc );
  }
  
	
  /* Create threads */
	status = tx_thread_create(&tg_tx_thread_hwd, /* Pointer to the thread   */  
													 "tg_tx_thread",      /* Thread's name           */  
													 tg_tx_thread, /* Thread's entry function */  
													 0,                  /* Entry function input     */  
													 tg_tx_thread_stack,     /* Thread's stack start    */  
													 TG_THREAD_STACK_SIZE,    /* Thread's stack size      */  
													 TG_THREAD_PRIORITY,/* Thread priority          */  
													 TG_THREAD_PRIORITY,/* Preemption threshold     */  
													 TX_NO_TIME_SLICE,   /* Time slice               */  
													 TX_AUTO_START);     /* Automatic start          */  
													 
	if(status != TX_SUCCESS) {                                                     
		printf( "Could not create generator test" );
  	return -1;                                                                    
	}              
	
	 /* Create threads */
	status = tx_thread_create(&tg_rx_thread_hwd, /* Pointer to the thread   */  
													 "tg_tx_thread",      /* Thread's name           */  
													 tg_rx_thread, /* Thread's entry function */  
													 0,                  /* Entry function input     */  
													 tg_rx_thread_stack,     /* Thread's stack start    */  
													 TG_THREAD_STACK_SIZE,    /* Thread's stack size      */  
													 TG_THREAD_PRIORITY,/* Thread priority          */  
													 TG_THREAD_PRIORITY,/* Preemption threshold     */  
													 TX_NO_TIME_SLICE,   /* Time slice               */  
													 TX_AUTO_START);     /* Automatic start          */  
	
	if( status != TX_SUCCESS ) {                                                     
		printf( "Could not create generator test" );
		return -1;                                                                    
	} 

	/* Create stats threads */
	status = tx_thread_create(&tg_stats_thread_hwd, /* Pointer to the thread   */  
													 "tg_stats_thread",      /* Thread's name           */  
													 tg_stats_thread, /* Thread's entry function */  
													 0,                  /* Entry function input     */  
													 tg_stats_thread_stack,     /* Thread's stack start    */  
													 TG_STAT_THREAD_STACK_SIZE,    /* Thread's stack size      */  
													 TG_THREAD_PRIORITY,/* Thread priority          */  
													 TG_THREAD_PRIORITY,/* Preemption threshold     */  
													 TX_NO_TIME_SLICE,   /* Time slice               */  
													 TX_AUTO_START);     /* Automatic start          */  
	
	if(status != TX_SUCCESS) {                                                     
		printf( "Could not create generator test" );
		return -1;                                                                    
	} 

	return 0;
}

int craton_rf_init( void )
{
	atlk_rc_t 	rc        = ATLK_OK;
	int 				i					= 0;
	int					rf_freq[2] = { RF_FREQ_1 , RF_FREQ_2 };  

  rc = mib_default_service_get(&mib_service);
  if (atlk_error(rc)) {
    fprintf(stderr, "mib_default_service_get: %s\n", atlk_rc_to_str(rc));
    return (-1);
  }

	printf("Disable vca log\n");
	rc = mib_set_vcaLogMode (mib_service, MIB_vcaLogMode_off );
	if (atlk_error(rc)) {
    printf( "ERROR :  mib_set_vcaLogMode failed, %s\n", atlk_rc_to_str(rc));
  }
	
	for ( i = 1; i <= 2; i++) {
	
		printf( "\nV2X-CLI setting RF %d to Frequency %d with power %d\n", i, rf_freq[i-1], RF_POWER );
		rc = mib_set_wlanDefaultTxPower(mib_service, i, RF_POWER ); 
		if ( atlk_error(rc) ) {
  		printf( "ERROR :  mib_set_wlanDefaultTxPower  failed for if %d and value %d: %s\n", i, RF_POWER, atlk_rc_to_str(rc) );
		}
		
		rc = mib_set_wlanFrequency( mib_service, i, rf_freq[i-1] ); 
		if (atlk_error(rc)) {
			printf( "ERROR :  wlanFrequency  failed for if %d and value %d: %s\n", i, rf_freq[i-1], atlk_rc_to_str(rc));
      return (-1);
		}
	}
  return ATLK_OK;
  
}

int cmd_set_rate(cli_instance_t *cli, const char *command, char *argv[], int argc)
{
	int rate 	= 0;
	int rc		= 0;
  /* Handle get rate */
	if ( argc == 0 ) {
    if ( tg_frame_sleep == 0 ) {
      cli_print( cli, "Tg is not active, {tg start} to activate the tg", rate );
    }
    else {
      rate = (uint32_t) (1000000.0 / (double) tg_frame_sleep);
      cli_print( cli, "Tg rate is %d Packets/Sec", rate );
    }
	}
	else if ( argc == 1 && argv[0] != NULL ) {

		rc = sscanf(argv[0], "%d", &rate);              
		if ( rc > 0 ) { 
    
      if ( rate == 0 ) { /* Pause traffic */
        tg_frame_sleep = 0;
      }
      else {
        frame_rate = rate;
        tx_frames[0] = rate;
        tg_frame_sleep = (uint32_t) (1000000.0 / (double) rate); /* uSec */
        cli_print( cli, "Note : sleep was set to %u", tg_frame_sleep );
      }
		}
		else { 
			cli_print( cli, "ERROR : failed to retreive frame rate" );
		}
	}
	else {
		return (-1);
	}

  return 0;
}

#define GET_VALUE(_parameter_,_var_,_idx_,_user_msg_,_fmt_) {  \
    if ( (argv[_idx_] != NULL) && (strcmp(argv[_idx_], _parameter_) == 0) ) {           \
      unsigned int value = 0;                           \
      int rc = 0;                               \
      int par_idx = (_idx_+1);                          \
      if (!argv[par_idx] && !&argv[par_idx]) {          \
          cli_print(cli, _user_msg_);                   \
          return CLI_OK;                                \
      }                                                 \
      rc = sscanf(argv[par_idx], _fmt_, &value);              \
      if ( rc > 0 ) { \
        _var_ = value;                                   \
        /*cli_print( cli, "DEBUG : Processed parameter %s, value %d" , _parameter_ , value );*/\
      } \
      else { \
        cli_print( cli, "ERROR : Processed parameter %s, value #_fmt_ failed" , _parameter_ , value );\
      }\
    } \
    else {\
      cli_print( cli, "ERROR : Expected %s pair, received %s" , _parameter_ , argv[_idx_] );\
    }\
}


int cmd_tg_tx(cli_instance_t *cli, const char *command, char *argv[], int argc)
{
  uint32_t  cam_fps = 350, denm_fps = 50, unsigned_fps = 30, bad_sign_fps = 20;
  int32_t  rc = 0;   

  /* Hold Tx thread */
  tg_frame_sleep = 0;

  if ( (argc == 0) || (argc % 2) ) {
    cli_print( cli, "Error : missing command parameters. \n\rUsage exapmle :  tg tx -stations 40 -cam 350 -denm 50 -unsigned 20 -bad_signed 30");
    return 0;
	}

  GET_VALUE( "-stations", stations_simulated, 0, "Expected stations", "%u" )
  GET_VALUE( "-cam", tx_frames[0], 2, "Expected -cam parameter" , "%u")
  GET_VALUE( "-denm", tx_frames[1], 4, "Expected -denm parameter", "%u" )
  GET_VALUE( "-unsigned", tx_frames[2], 6, "Expected -unsigned parameter", "%u" )
  GET_VALUE( "-bad_signed", tx_frames[3], 8, "Expected -bad_signed parameter", "%u" )

  uint32_t total_fps = tx_frames[0] + tx_frames[1] + tx_frames[2] + tx_frames[3];

  if ( total_fps >= 1000 ) {
    cli_print( cli, "Error : total fps exceed 1000.");
    return (-1);
	}

  if ( (total_fps == 0) || (stations_simulated == 0) ) {
    return 0;
  }

  /* Activate security */
  sec_active = 1;
  /* Set system frame rate vars */
  frame_rate = total_fps;
  
  tg_frame_sleep = (uint32_t) (1000000.0 / (double) total_fps);

  cli_print( cli, "Starting TG with rate %d, %d Cams, %d Denms, %d Unsigned %d bas_signed\nTotal stations %d, sleep rate %d", total_fps , tx_frames[0] ,tx_frames[1], tx_frames[2], tx_frames[3], stations_simulated, tg_frame_sleep );

  /* Start counters printing */
  cntr_print = 1;
  
  return 0;
  
}



int cmd_tg_pause(cli_instance_t *cli, const char *command, char *argv[], int argc)
{
  tg_frame_sleep = 0;
  cntr_print &= cntr_print;
  return 0;
}

int cmd_tg_resume(cli_instance_t *cli, const char *command, char *argv[], int argc)
{
   uint32_t total_fps = tx_frames[0] + tx_frames[1] + tx_frames[2] + tx_frames[3];

  if ( total_fps >= 1000 ) {
    cli_print( cli, "Error : total fps exceed 1000.");
    return (-1);
	}

  if ( (total_fps == 0) || (stations_simulated == 0) ) {
    return 0;
  }

  /* Set system frame rate vars */
  frame_rate = total_fps;
  tg_frame_sleep = (uint32_t) (1000000.0 / (double) total_fps);
  cntr_print &= cntr_print;
  return 0;
}

int cmd_set_stations(cli_instance_t *cli, const char *command, char *argv[], int argc)
{
	int stations 	= 0;
	int rc		= 0;

  /* Handle get  */
	if ( argc == 0 ) {
		cli_print( cli, "TG is simulate %d stations", stations_simulated );
	}
	else if ( argc == 1 && argv[0] != NULL ) {

		rc = sscanf(argv[0], "%d", &stations);              
		if ( rc > 0 ) { 
    
      if ( stations == 0 ) { /* Pause traffic */
        cli_print( cli, "ERROR, Number of simulated station must be at least 1");
      }
      else {
        stations_simulated = stations;                                
      }
		}
		else { 
			cli_print( cli, "ERROR : failed to retreive station count" );
		}
	}
	else {
		return (-1);
	}

  return 0;
}

int cmd_counters_print(cli_instance_t *cli, const char *command, char *argv[], int argc)
{
	int print_cntr 	= 0;
	int rc		= 0;

  /* Handle get  */
	if ( argc == 0 ) {
		return (-1);
	}
	
	if ( argc == 1 && argv[0] != NULL ) {

		rc = sscanf(argv[0], "%d", &print_cntr);              
		if ( rc > 0 ) { 
			cntr_print = (uint8_t) print_cntr;
		}
	}
  
  return 0;
}


int cmd_set_security_state(cli_instance_t *cli, const char *command, char *argv[], int argc)
{
	int       rc		  = 0;
  uint32_t  value   = 0;

  /* Handle get  */
	if ( argc == 0 ) {
    cli_print( cli, "Security status is : %d", sec_active );
		return (-1);
 	}
	
	if ( argc == 1 && argv[0] != NULL ) {

		rc = sscanf(argv[0], "%d", &value);              
		if ( rc > 0 ) { 
			sec_active = (uint8_t) value;
		}
	}
  return 0;

}

int cmd_full_cert(cli_instance_t *cli, const char *command, char *argv[], int argc)
{
  int       rc		  = 0;
  uint32_t  value   = 0;

  /* Handle get  */
	if ( argc == 0 ) {
    cli_print( cli, "Security status is : %d", sec_active );
		return (-1);
 	}
	
	if ( argc == 1 && argv[0] != NULL ) {

		rc = sscanf(argv[0], "%d", &value);              
		if ( rc > 0 ) { 

      if ( value < 2 ) {
  			send_full_chain_rate = (uint8_t) value;
      }
      else {
        send_full_certificate();
      }
		}
	}
  return 0;
  
}




void craton_user_init(void)
{
	atlk_rc_t rc;
	cli_instance_t *cli = NULL;
	struct cli_command *command = NULL, *head = NULL;
  tg_frame_sleep = 0;
  
	/* Get CRATON UART CLI instance */
	craton_rf_init();
	
		
  rc = cli_instance_get(&cli, CLI_INSTANCE_TYPE_UART);
  if (atlk_error(rc)) {
    fprintf(stderr, "cli_instance_get: %s\n", atlk_rc_to_str(rc));
  }

  if ( cli == NULL ) {
    printf( "cli_instance_get return NULL: %s\n", atlk_rc_to_str(rc));
  }
    
	
	/* Get default ECC service */
  rc = ecc_default_service_get(&ecc_service);
  if (atlk_error(rc)) {
    fprintf(stderr,"ecc_default_service_get: %s\n", atlk_rc_to_str(rc));
  }

  /* Create ECC verification socket */
	rc = ecc_signing_socket_create ( ecc_service, &ecc_sign_socket );
  if (atlk_error(rc)) {
    fprintf(stderr, "ecc_signing_socket_create: %s\n", atlk_rc_to_str(rc));
  }

  /* Compute SHA-256 hash value of certificate */
  /*
  rc = sha_hw_sha256_compute(at_cert, sizeof(at_cert), &at_cert_digest);
  if (atlk_error(rc)) {
    fprintf(stderr, "sha_hw_sha256_compute: %s", atlk_rc_to_str(rc));
  }
  */
  /* Print computed SHA-256 digest */
  //printf("SHA-256 hash digest computed on at_cert:\n");
  //printf("  Digest: " SHA_DIGEST_FMT "\n", SHA_DIGEST_FMT_ARGS(at_cert_digest));


	rc = tg_init();
  if ( atlk_error(rc) != ATLK_OK ) {
    printf( " ERROR : tg_init failed !! with error %d\n" , rc );
  }

	
  /* Register example command */
	head = cli_register_command(cli, NULL, "tg", NULL, PRIVILEGE_UNPRIVILEGED, MODE_ANY, "Traffic generator options");

  cli_register_command(cli, head, "rate", cmd_set_rate, PRIVILEGE_UNPRIVILEGED, MODE_ANY, "Set TG transmit rate");
  cli_register_command(cli, head, "pause", cmd_tg_pause, PRIVILEGE_UNPRIVILEGED, MODE_ANY, "Pause TG");
  cli_register_command(cli, head, "resume", cmd_tg_resume, PRIVILEGE_UNPRIVILEGED, MODE_ANY, "Resume TG");

  command = cli_register_command(cli, head, "stations", cmd_set_stations, PRIVILEGE_UNPRIVILEGED, MODE_ANY, "Set number of simulated stations.");
  command = cli_register_command(cli, head, "print_counters", cmd_counters_print, PRIVILEGE_UNPRIVILEGED, MODE_ANY, "Set number of simulated stations.");
  // command = cli_register_command(cli, head, "cert", cmd_print_cert_info, PRIVILEGE_UNPRIVILEGED, MODE_ANY, "Print info regards certificates.");
  command = cli_register_command(cli, head, "sec", cmd_set_security_state, PRIVILEGE_UNPRIVILEGED, MODE_ANY, "Set security status.");
  command = cli_register_command(cli, head, "full", cmd_full_cert, PRIVILEGE_UNPRIVILEGED, MODE_ANY, "Send chain certificate");
  command = cli_register_command(cli, head, "tx", cmd_tg_tx, PRIVILEGE_UNPRIVILEGED, MODE_ANY, "Send chain certificate");


  printf( "Prepare sha signutures\n" );
  int i = 0;
  for ( i = 0 ; i < NUMBER_OF_CERTS; i++ ) {

    rc = sha_hw_sha256_compute(at_certs[i], sizeof(at_certs[i]), &at_cert_digest[i]);
    if (atlk_error(rc)) {
      fprintf(stderr, "sha_hw_sha256_compute: %s", atlk_rc_to_str(rc));
    }
    else {
      printf("  Digest %d: " SHA_DIGEST_FMT "\n", i , SHA_DIGEST_FMT_ARGS(at_cert_digest[i]) );
    }
  }
 
  
}

#else
void craton_user_init(void)
{

}
#endif

